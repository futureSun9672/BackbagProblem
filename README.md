## 背包问题 BackbagProblem
### 1.01背包问题
有n个物品，每种物品只有1个，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？
### 2.完全背包问题
有n个物品，每种物品有无数个，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？
### 3.算法
暴力破解法：找出所有物品组合，判断是否能装入背包，并求出价值，找出价值最大的一组。复杂度; C(1,n) + C(2,n) + ···+C(n, n) = 2的n次方

动态规划法：
	依次考虑背包体积W，从0到m,物品从没有到考虑第i种，当叠加到最大体积和最多物品数时，就是要求解的问题。
	
### 4.背包问题的关键点：
**（1）下标的意义**
i 物品类 从1开始 
v(i) ：物品i的价值
w(i):  物品i的重量
F(i, j) : 在背包体积为 j 时，考虑物品0 到物品 i 的情况下可以装下的最大价值

j 背包容量，从0增加到最大容量
F：在考虑了物品从0~i容量为j的情况下，可以放的最大价值

**（2）数组的初始化**
背包容量从零开始，零列都为0，一维数组初始化都为0
在二维数组中，若不特殊处理第1行，需要增加一个0行
 
**（3）递推公式**
在容量j小于当前物品重量时， F为上一行值的值不变
在容量j大于物品的重量时，比较上一行的值和背包当前容量减去物品的容量后取得的最大值与当前物品的价值之和，取最大的那个
j<w(i)      F(i, j)= F(i-1, j)
j>=w(i)     F(i, j)=max｛F(i-1, j)，F( i-1,  j-w(i)） + v(i) ｝

一维数组：
j<w( j )       F( j ) = F( j ) 
j>=w( j )     F( j )=max｛F( j ) ，F( j - w( j )  ) + v( j )  ｝

完全背包：

```cpp
for(unsigned int i=0;i < weight.size(); i++) // 循环物品i
	{ 
		for (unsigned int j = 1; j < M.size(); j++) // 循环背包，从1开始，0为j=0时的值
		{
			// if(j>=weight[i]) 初始值为0，不需要改变
			if(j>=weight[i]) M[j] = max(M[j], M[j - weight[i]] + value[i]); // 
			//cout << M[j] << " ";
			printf("%d%t  ", M[j]);
		}		
		cout << "\n";
	}
```

01背包

```cpp
for (unsigned int i = 0; i < weight.size(); i++) // 循环物品i
	{
		for (unsigned int j = bagsize ; j > 0; j--) // 循环背包，从1开始，0为j=0时的值，为防止覆盖，从后往前遍历
		{
			if (j >= weight[i]) M[j] = max(M[j], M[j - weight[i]] + value[i]);
			//cout << M[j] << " ";			
		}
		// 打印当前行
		for (unsigned int k = 1; k < M.size(); k++)
		{
			printf("%d  ", M[k]);
		}
		cout << endl;
	}
```

采用一维数组时，当前值由本格值和左边的值决定，即求下一行时，可以将上一行覆盖掉，因为前面几行在后面已经没有用。为保证不重复，01背包中要从后往前遍历，防止覆盖，而完全背包则恰好相反，迭代时用F( j ) 代替 F( i,  j )。

**（4）遍历顺序**
在01背包中，先遍历物品和先便利背包都可以，若采用一维数组，需要从后往前遍历，保证数组前的值是没有被覆盖的；
在完全背包中，采用一维数组需要从前往后遍历，并且必须先遍历物品，再遍历背包


	



